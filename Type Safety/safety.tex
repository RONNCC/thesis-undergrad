\documentclass[11pt]{article}

%%%%%%%%%%%%%%%%%%%% Title %%%%%%%%%%%%%%%%%%%%%
\title{Intersections and Unions for Session Typed Concurrency}
\date{February 22, 2015}
\author{Josh Acay}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%% Default packages %%%%%%%%%%%%%%%%
\usepackage{fullpage}           % Page style
\usepackage{amsmath, amsfonts, amsthm, amssymb, mathtools} % Math
\usepackage{proof}              % For inference rules
\usepackage{mathpartir}         % Automatic rule layout
\usepackage{enumerate, calc}    % Environments
\usepackage{syntax}             % BNF grammar
\usepackage{color}              % For todos
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%% Page outline %%%%%%%%%%%%%%%%%
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%% Theorem environments %%%%%%%%%%%%%
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{cor}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
%\newtheorem{task}{Task}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%% Generic Macros %%%%%%%%%%%%%%%%
\newcommand\todo[1]{{\huge \color{red} TODO: {#1}}}

%%% Paired delimiters
\DeclarePairedDelimiter\parens{(}{)}             % parenthesis
\DeclarePairedDelimiter\bracks{\lbrack}{\rbrack} % brackets
\DeclarePairedDelimiter\braces{\lbrace}{\rbrace} % brackets
\DeclarePairedDelimiter\abs{\lvert}{\rvert}      % absolute value
\DeclarePairedDelimiter\norm{\lVert}{\rVert}     % double verts
\DeclarePairedDelimiter\angled{\langle}{\rangle} % angle brackets
\DeclarePairedDelimiterX\set[2]{\{}{\}}
  {#1 \mathrel{}\mathclose{}\delimsize|\mathopen{}\mathrel{} #2}


%%% Math
\newcommand{\sq}{\text{\ttfamily{\char'15}}} % Single quote
\newcommand{\qq}{\text{\ttfamily"}}          % Double quote
\newcommand{\qquote}[1]{\qq #1\qq{}}         % Strings

\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}

\DeclareMathOperator\dom{dom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%% Document specific macros %%%%%%%%%%%

%% Types

\newcommand\indexVar{x}

\newcommand\sub{\le}
\newcommand\lolli{\multimap}
\newcommand\terminate{\mathbf{1}}
\newcommand\tensor{\otimes}
\newcommand\lab{lab}
\newcommand\internal{\oplus}
\newcommand\external{\&}
\newcommand\internals[2]{\internal\braces{\lab_\indexVar : {#1}_\indexVar}_{\indexVar \in #2}}
\newcommand\externals[2]{\external\braces{\lab_\indexVar : {#1}_\indexVar}_{\indexVar \in #2}}
\newcommand\intersect{\mathbin{\sqcap}}
\newcommand\union{\mathbin{\sqcup}}


%% Terms
\newcommand\seq{\;;\;}
\newcommand\tbranch[2]{#1 \rightarrow #2}
\newcommand\tbranches[2]{\braces{\lab_\indexVar \rightarrow {#1}_\indexVar}_{\indexVar \in #2}}

\newcommand\tfwd[2]{#1 \leftarrow #2}
\newcommand\tspawn[3]{#1 \leftarrow #2 \seq #3}
\newcommand\tspawnType[4]{#1 \leftarrow #2 : #3 \seq #4}
\newcommand\tclose[1]{\mathrm{close}\;#1}
\newcommand\twait[2]{\mathrm{wait}\;#1 \seq #2}
\newcommand\tsend[4]{\mathrm{send}\; #1 \; \parens{#2 \leftarrow #3} \seq #4}
\newcommand\trecv[3]{#1 \leftarrow \mathrm{recv} \; #2 \seq #3}
\newcommand\tcase[2]{\mathrm{case}\;#1\;\mathrm{of}\;#2}
\newcommand\tselect[3]{#1 . \lab_{#2} \seq #3}

\newcommand\monad[1]{\braces{#1}}


%% Inference
\newcommand\irb[1]{\texttt{#1}}
\newcommand\Right{\irb{R}}
\newcommand\Left{\irb{L}}
\newcommand\Sub[1]{\text{Sub-}#1}
\newcommand\id{\irb{id}}
\newcommand\cut{\irb{cut}}


%% Typing
\newcommand{\remove}{\mathbin{/}}
\newcommand{\emptyCtx}{\emptyset}
\newcommand{\ctx}{\Psi}
\newcommand{\config}{\Omega}

% Original typing judgment
\newcommand\typeProc[3]{#1 :: \parens{#2 : #3}}
\newcommand\typeS[4]{#1 \vdash \typeProc{#2}{#3}{#4}}
\newcommand\typeSJ{\typeS{\ctx}}

% Bidirectional typing
\newcommand\typeBi[4]{#1 \Vdash #2 :: \parens{#3 : #4}}
\newcommand\typeBiJ{\typeBi{\ctx}}
\newcommand{\typeList}{\alpha}
\DeclareMathOperator\all{all}
\DeclareMathOperator\any{any}

\newcommand\stepArrow{\longrightarrow}
\newcommand\steps[2]{#1 \stepArrow #2}
\newcommand\stepsMany[2]{#1 \stepArrow^* #2}

\newcommand\proc[2]{\irb{proc}_{#1}\parens{#2}}

\newcommand\provides[2]{\models #1 :: \parens{#2}}
\newcommand\poised[1]{#1\;\mathtt{poised}}
\newcommand\valid[4]{\models \typeProc{\state{#1}{#2}}{#3}{#4}}

%% Induction
\newcommand\pred[1]{\mathcal{P}\parens*{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%% Document body %%%%%%%%%%%%%%%%%

\begin{document}

%% Title page
\maketitle

%% Document

\section{Sessions and Processes}

The syntax and intended meanings of session types are as follows:

\begin{center}
\begin{tabular}{l c l l}
  $A, B, C$ & ::= & $\terminate$        & send \texttt{end} and terminate \\
            & $|$ & $A \tensor B$       & send channel of type $A$ and continue as $B$ \\
            & $|$ & $\internals{A}{I}$  & send $\lab_i$ and continue as $A_i$ \\
            & $|$ & $A \lolli B$        & receive channel of type $A$ and continue as $B$ \\
            & $|$ & $\externals{A}{I}$  & receive $\lab_i$ and continue as $A_i$ \\
\end{tabular}
\end{center}

Below is a summary of the process expressions, with the sending construct
followed by the matching receiving construct.

\begin{center}
\begin{tabular}{l c l l}
  $P, Q, R$ & ::= & $\tspawn{x}{P_x}{Q_x}$     & cut (spawn) \\
            & $|$ & $\tfwd c d$                & id (forward) \\
            & $|$ & $\tclose c \mid \twait c P$  & $\terminate$ \\
            & $|$ & $\tsend{c}{y}{P_y}{Q} \mid \trecv{x}{c}{R_x}$ & $A \tensor B,$ $A \lolli B$ \\
            & $|$ & $\tselect{c}{}{P} \mid \tcase c {\tbranches Q i}$  & $\externals A I,$ $\internals A I$
\end{tabular}
\end{center}


\section{Subtyping}

The main purpose of subtyping is to restrict internal choice, relax external choice, and to deal with intersections and unions. We give algorithmic rules for the subtyping relation.

\begin{mathpar}
  \infer[\Sub{\terminate}]{\terminate \sub \terminate}{}
  \and \infer[\Sub\tensor]{A \tensor B \sub A' \tensor B'}
    {A \sub A' & B \sub B'}
  \and \infer[\Sub\internal]{\internals{A}{I} \sub \internals{A'}{J}}
    {I \subseteq J \and A_k \sub A'_k~\text{for}~k \in J}
  \and \infer[\Sub\lolli]{A \lolli B \sub A' \lolli B'}
    {A' \sub A & B \sub B'}
  \and \infer[\Sub\external]{\externals{A}{I} \sub \externals{A'}{J}}
    {J \subseteq I \and A_k \sub A'_k~\text{for}~k \in J}
\end{mathpar}

We make use of subtyping with the subsumption rules:

\begin{mathpar}
  \infer[\irb{Sub}\Right]{\typeSJ{P}{c}{A'}}
    {\typeSJ{P}{c}{A} & A \sub A'}
  \and \infer[\irb{Sub}\Left]{\typeS{\ctx, c : A}{P}{d}{B}}
    {\typeS{\ctx, c : A'}{P}{d}{B} & A \sub A'}
\end{mathpar}

Subtyping extends to contexts in the obvious way: $\ctx \sub \ctx'$ if and only if $\ctx = (c_1 : A_1, \ldots, c_n : A_n),$ $\ctx' = (c_1 : A_1', \ldots, c_n : A_n'),$ and $A_i \sub A_i'$ for $1 \le i \le n.$

We require the subtyping relation to be an equivalence, that is, it should satisfy reflexivity and transitivity. Since we want an algorithmic system, we do not want to add these as rules. Thus, we have the following admissibility theorem:

\begin{theorem}
  $\sub$ is an equivalence relation:
  \begin{itemize}
    \item $A \sub A$ for all types $A.$
    \item $A \sub B$ and $B \sub C$ implies $A \sub C$ for all types $A, B, C.$
  \end{itemize}
\end{theorem}

\section{Process Assignment}

We have the following rules to assign sessions to processes:

\begin{mathpar}
  % id and cut
  \infer[\id]{ \typeS {c : A} {\tfwd{d}{c}} {d} {A} }
    {}
  \and \infer[\cut]{ \typeS {\ctx, \ctx'} {\tspawn{c}{P_c}{Q_c}} {d} {D} }
    { \typeS {\ctx} {P_c} {c} {A}
    & \typeS {\ctx', c : A} {Q_c} {d} {D}
    }
  % Terminate
  \and \infer[\terminate\Right]{\typeS{\emptyCtx}{\tclose c}{c}{\terminate}}
    {}
  \and \infer[\terminate\Left]{\typeS{\ctx, c : \terminate}{\twait c P}{d}{A}}
    {\typeSJ{P}{d}{A}}
  % Tensor
  \and \infer[\tensor\Right]{\typeS{\ctx, \ctx'}{\tsend{c}{d}{P_d}{Q}}{c}{A \tensor B}}
    { \typeS{\ctx}{P}{d}{A}
    & \typeS{\ctx'}{Q}{c}{B}
    }
  \and \infer[\tensor\Left]{ \typeS{\ctx, c : A \tensor B}{\trecv{d}{c}{P_d}}{e}{E} }
    { \typeS{\ctx, d : A, c : B}{P_d}{e}{E} }
  % Internal choice
  \and \infer[\internal\Right]{\typeSJ { \tselect{c}{i}{P} } {c} {\internals{A}{I}} }
    { i \in I
    & \typeSJ{P}{c}{A_i}
    }
  \and \parens*{\infer[\internal\Right]{\typeSJ { \tselect{c}{}{P} } {c} {\internal \braces{\lab : A}} }
    { \typeSJ{P}{c}{A}
    }
  }
  \and \infer[\internal\Left]{ \typeS { \ctx, c : \internals{A}{I} } { \tcase{c}{\tbranches{P}{J}} } {d} {D} }
   { I \subseteq J
   & \typeS{\ctx, c : A_k}{P_k}{d}{D}~\text{for}~k\in I
   }
  % Implication
  \and \infer[\lolli\Right]{ \typeS{\ctx}{\trecv{d}{c}{P_d}}{c}{A \lolli B} }
    { \typeS{\ctx, d : A}{P_d}{c}{B} }
  \and \infer[\lolli\Left]{\typeS{\ctx, \ctx', c : A \lolli B}{ \tsend{c}{d}{P_d}{Q} } {e}{E}}
    { \typeS{\ctx}{P_d}{d}{A}
    & \typeS{\ctx', c : B}{Q}{e}{E}
    }
  % External choice
  \and \infer[\external\Right]{ \typeSJ { \tcase{c}{\tbranches{P}{I}} } {c} {\externals{A}{J}} }
   { J \subseteq I
   & \typeSJ{P_k}{c}{A_k}~\text{for}~k\in J
   }
  \and \infer[\external\Left]{\typeS{\ctx, c : \externals{A}{I}} { \tselect{c}{i}{P} } {d} {D}}
    { i \in I
    & \typeS{\ctx, c : A_i}{P}{d}{D}
    }
\end{mathpar}

\todo{Note that we can simplify $\internal\Right,$ $\internal\Left,$ $\external\Right,$ $\external\Left$ using subtyping.}


\section{Intersections}

We extend the syntax of types with a new construct:
\begin{center}
\begin{tabular}{l c l l}
  $A, B, C$ & ::= & \ldots                & everything from before \\
            & $|$   & $A \intersect B$    & act as both $A$ and $B$ \\
\end{tabular}
\end{center}

Process expressions remain unchanged. $A \intersect B$ means that a process satisfies both $A$ and $B.$ Intersections correspond to logical conjunction. The left rules are provided for reference only since they are derivable from the subtyping relation.

\begin{mathpar}
  \infer[\intersect\Right]{\typeSJ{P}{c}{A \intersect B}}
    {\typeSJ{P}{c}{A} & \typeSJ{P}{c}{B}}
  \and \parens*{\infer[\intersect\Left_1]{\typeS{\ctx, c : A \intersect B}{P}{d}{D}}
    {\typeS{\ctx, c : A}{P}{d}{D}}}
  \and \parens*{\infer[\intersect\Left_2]{\typeS{\ctx, c : A \intersect B}{P}{d}{D}}
    {\typeS{\ctx, c : B}{P}{d}{D}}}
\end{mathpar}

We have the following (algorithmic) subtyping rules for intersections:

\begin{mathpar}
  \infer[\Sub{\intersect}\Right]{A \sub B_1 \intersect B_2}
    {A \sub B_1 \and A \sub B_2}
  \and \infer[\Sub{\intersect}\Left_1]{A_1 \intersect A_2 \sub B}
    {A_1 \sub B}
  \and \infer[\Sub{\intersect}\Left_2]{A_1 \intersect A_2 \sub B}
    {A_2 \sub B}
\end{mathpar}

Intersections also have a distributivity rule for each construct in the system. We will leave these out for now, and later add them by proving they are admissible. This way, they do not affect the preservation and progress theorems.


\section{Unions}

Unions are represented by the following syntactic construct:
\begin{center}
\begin{tabular}{l c l l}
  $A, B, C$ & ::= & \ldots                & everything from before \\
            & $|$   & $A \union B$        & act as either $A$ or $B$
\end{tabular}
\end{center}

Unions are the dual of intersections, which means they correspond to logical disjunction. Unions express the property that a process behaves as either $A$ or $B.$ Being the dual to intersections, the right rules are derivable by subsumption.

\begin{mathpar}
  \parens*{\infer[\union\Right_1]{\typeSJ{P}{c}{A \union B}}
    {\typeSJ{P}{c}{A}}}
  \and \parens*{\infer[\union\Right_2]{\typeSJ{P}{c}{A \union B}}
    {\typeSJ{P}{c}{B}}}
  \and \infer[\union\Left]{\typeS{\ctx, c : A \union B}{P}{d}{D}}
    {\typeS{\ctx, c : A}{P}{d}{D} & \typeS{\ctx, c : B}{P}{d}{D}}
\end{mathpar}

Unions have the following (algorithmic) subtyping rules:
\begin{mathpar}
  \infer[\Sub{\union}\Right_1]{A \sub B_1 \union B_2}
    {A \sub B_1}
  \and \infer[\Sub{\union}\Right_1]{A \sub B_1 \union B_2}
    {A \sub B_2}
  \and \infer[\Sub{\union}\Left]{A_1 \union A_2 \sub B}
    {A_1 \sub B & A_2 \sub B}
\end{mathpar}

We again leave out the distributivity rules.


\section{Bidirectional Type Checking}

The previously given typing rules are logically justified and they are the rules we want. However, they have two problems in practice: (1) converting them to a type-checking algorithm is non-obvious, (2) non-structural rules prevent simple inversion lemmas which forces us to use nested-induction in the proofs of progress and preservation theorems, leading to many cases. To remedy this situation, we give bidirectional algorithmic rules and prove soundness and completeness with respect to the previous system.

\subsection{Type Assignment}

There are four major changes in the bidirectional system: (1) the context becomes a multi-set mapping channels to multiple types, (2) the checked type becomes a set of types, so we have multiple types on the right, (3) the sub-typing is restricted to forwarding, (4) cut rule gets a type signature for the spawned process.

Rules for intersection and union are as follows:

\begin{mathpar}
  % Intersection
  \infer[\intersect\Right]{\typeBi \ctx P c {A \intersect B, \typeList}}
    { \typeBi \ctx P c {A, \typeList}
    & \typeBi \ctx P c {B, \typeList}
    }
  \and \infer[\intersect\Left]{\typeBi{\ctx, c : A \intersect B}{P}{d}{\typeList}}
    {\typeBi{\ctx, c : A, c : B}{P}{d}{\typeList}}
  % Union
  \\
  \infer[\union\Right]{\typeBi \ctx P c {A \union B, \typeList}}
    {\typeBi \ctx P c {A, B, \typeList}}
  \and \infer[\union\Left]{\typeBi{\ctx, c : A \union B} P d \typeList}
    { \typeBi {\ctx, c : A} P d \typeList
    & \typeBi {\ctx, c : B} P d \typeList
    }
\end{mathpar}

\todo{$\intersect\Right$ and $\union\Left$ are tricky. Logically, they are fine, but might need subtyping rules or lemmas.}

Structural rules are given below:

\begin{mathpar}
  % id and cut
  \infer[\id]{ \typeBi {\ctx, c : A} {\tfwd d c} {d} {A', \typeList} }
    { \ctx \remove c = \emptyset
    & A \sub A'
    }
  \and \infer[\cut]{ \typeBi {\ctx, \ctx'} {\tspawnType c {P_c} A {Q_c}} {d} \typeList }
    { \dom \ctx \cap \dom {\ctx'} = \emptyset
    & \typeBi \ctx {P_c} {c} {A}
    & \typeBi {\ctx', c : A} {Q_c} {d} {\typeList}
    }
  % Terminate
  \\ \infer[\terminate\Right]{\typeBi{\emptyCtx}{\tclose c}{c}{\terminate, \typeList}}
   {}
  \and \infer[\terminate\Left]{\typeBi{\ctx, c : \terminate}{\twait c P} d \typeList}
    { \typeBi {\ctx \remove c} P d \typeList}
  % Tensor
  \and \infer[\tensor\Right]{\typeBi{\ctx, \ctx'}{\tsend c d {P_d} Q }{c}{A \tensor B, \typeList}}
    { \ctx \cap \ctx' = \emptyset
    & \typeBi \ctx P d A
    & \typeBi {\ctx'} Q c B
    }
  \and \infer[\tensor\Left]{ \typeBi{\ctx, c : A \tensor B}{\trecv{d}{c}{P_d}}{e}{\typeList} }
    { \typeBi{\ctx \remove c, d : A, c : B}{P_d}{e}{\typeList} }
  % Internal choice
  \and \infer[\internal\Right]{\typeBi \ctx { \tselect{c}{i}{P} } {c} {\internals{A}{I}, \typeList }}
    { i \in I
    & \typeBi \ctx {P}{c}{A_i}
    }
  \and \infer[\internal\Left]{ \typeBi { \ctx, c : \internals{A}{I} } { \tcase{c}{\tbranches{P}{J}} } {d} {\typeList} }
   { I \subseteq J
   & \typeBi{\ctx \remove c, c : A_k}{P_k}{d}{\typeList}~\text{for}~k\in I
   }
  % Implication
  \and \infer[\lolli\Right]{ \typeBi{\ctx}{\trecv{d}{c}{P_d}}{c}{A \lolli B, \typeList} }
    { \typeBi{\ctx, d : A}{P_d}{c}{B} }
  \and \infer[\lolli\Left]{\typeBi{\ctx, \ctx', c : A \lolli B}{ \tsend{c}{d}{P_d}{Q} } {e}{\typeList}}
    { \ctx \cap \ctx' = \emptyset
    & \typeBi{\ctx}{P_d}{d}{A}
    & \typeBi{\ctx' \remove c, c : B}{Q}{e}{\typeList}
    }
  % External choice
  \and \infer[\external\Right]{ \typeBi \ctx { \tcase{c}{\tbranches{P}{I}} } {c} {\externals{A}{J}, \typeList} }
   { J \subseteq I
   & \typeBi \ctx {P_k}{c}{A_k}~\text{for}~k\in J
   }
  \and \infer[\external\Left]{\typeBi{\ctx, c : \externals{A}{I}} { \tselect{c}{i}{P} } {d} {\typeList}}
    { i \in I
    & \typeBi{\ctx \remove c, c : A_i}{P}{d}{\typeList}
    }
\end{mathpar}


\subsection{Properties}

\begin{lemma}[Weakening]
  The following are admissible:
  \begin{itemize}
    \item $\typeBi \ctx P c \typeList \implies \typeBi \ctx P c {A, \typeList}.$
    \item $\typeBi \ctx P c \typeList \implies \typeBi {\ctx, d : A} P c \typeList$ if $d \in \dom \ctx.$
  \end{itemize}
\end{lemma}
\begin{proof}
  By induction on the typing derivation.
\end{proof}

\begin{lemma}[Contraction]
  The following are admissible:
  \begin{itemize}
    \item $\typeBi \ctx P c {A, A, \typeList} \implies \typeBi \ctx P c {A, \typeList}.$
    \item $\typeBi {\ctx, d : A, d : A} P c \typeList \implies \typeBi {\ctx, d : A} P c \typeList.$
  \end{itemize}
\end{lemma}
\begin{proof}
  By induction on the typing derivation.
\end{proof}

\begin{lemma}[Invertibility]
  The following are admissible:
  \begin{description}
    \item[$(\intersect\Right)$] $\typeBi \ctx P c {A_1 \intersect A_2, \typeList} \iff \typeBi \ctx P c {A_1, \typeList} \text{ and } \typeBi \ctx P c {A_2, \typeList}.$
    \item[$(\intersect\Left)$] $\typeBi {\ctx, d : A_1 \intersect A_2} P c \typeList \iff
    \typeBi {\ctx, d : A_1, d : A_2} P c \typeList.$
    \item[$(\union\Right)$] $\typeBi \ctx P c {A_1 \union A_2, \typeList} \iff \typeBi \ctx P c {A_1, A_2, \typeList}.$
    \item[$(\union\Left)$] $\typeBi {\ctx, d : A_1 \union A_2} P c \typeList \iff
    \typeBi {\ctx, d : A_1} P c \typeList
    \text{ and } \typeBi {\ctx, d : A_2} P c \typeList.$
  \end{description}
\end{lemma}
\begin{proof}
  Backward direction is derivable by an application of $\intersect\Right,$ $\intersect\Left,$ $\union\Right,$ and $\union\Left$ respectively.

  Forward direction is by induction on the typing derivation.
\end{proof}

\begin{lemma}[Subtyping]
  \label{bi-sub}
  If $\ctx' \le \ctx,$ $\typeList \le \typeList',$ and $\typeBi \ctx P c \typeList,$ then $\typeBi {\ctx'} P c {\typeList'}.$
\end{lemma}
\begin{proof}
  By lexicographical induction on $\typeBi \ctx P c \typeList$ first, followed by $\ctx \le \ctx'$ and $\typeList \le \typeList'.$
\end{proof}


\subsection{Soundness and Completeness}

We relate the two typing judgments by proving the soundness and completeness of the bidirectional system with respect to the declarative system.

\begin{theorem}[Soundness]
If $\typeBi \ctx P c \typeList,$ then $\typeS {\all{(\ctx)}} P c {\any{(\typeList)}}.$
\end{theorem}
\begin{proof}
  By induction on the derivation of $\typeBi \ctx P c \typeList.$ The only tricky parts are the proofs of the following lemmas required for $\intersect\Right$ and $\union\Left$:
  \begin{itemize}
    \item If $\typeS \ctx P c {A_1 \union B}$ and $\typeS \ctx P c {A_2 \union B},$ then $\typeS \ctx P c {(A_1 \intersect A_2) \union B}.$
    \item If $\typeS {\ctx, c : A_1 \intersect B} P d C$ and $\typeS {\ctx, c : A_2 \intersect B} P d C,$ then $\typeS {\ctx, c : (A_1 \union A_2) \intersect B} P d C.$
  \end{itemize}
\end{proof}

\begin{theorem}[Completeness]
If $\typeS \ctx P c A,$ then $\typeBi \ctx P c A.$
%If $\typeS \ctx P c A,$ then for all $\ctx'$ and $A'$ such that $\ctx' \sub \ctx$ and $A \sub A',$ $\typeBi {\ctx'} P c {A'}.$
\end{theorem}
\begin{proof}
  By induction on the derivation of $\typeS \ctx P c A$ using \ref{bi-sub} for $\irb{Sub}\Right$ and $\irb{Sub}\Left.$
\end{proof}

\section{Operational Semantics}

Processes compute according to the following rules. The braces ($\braces{\ldots}$) indicate a contextual monad.

\begin{align*}
  \irb{id}     \hspace{1em} & : \proc{c}{\tfwd{c}{d}} \lolli \monad{c = d} \\
  %
  \irb{cut}    \hspace{1em} & : \proc{c}{\tspawn{x}{P_x}{Q_x}}
      \lolli \monad{\exists a. \proc{a}{P_a} \otimes \proc{c}{Q_a}} \\
  %
  \irb{one} \hspace{1em} & : \proc{c}{\tclose{c}} \otimes \proc{d}{\twait{c}{P}}
    \lolli \monad{\proc{d}{P}} \\
  %
  \irb{tensor} \hspace{1em} & : \proc{c}{\tsend{c}{x}{P_x}{Q}} \otimes \proc{e}{\trecv{x}{c}{R_x}} \\
    & \hspace{2em} \lolli \monad{ \exists a. \proc{a}{P_{a}} \otimes \proc{c}{Q} \otimes \proc{e}{R_{a}} } \\
  %
  \irb{internal} \hspace{1em} & : \proc{c}{\tselect{c}{i}{P}} \otimes \proc{d}{\tcase{c}{\tbranches Q I}} \otimes i \in I \\
    & \hspace{2em} \lolli \monad{ \proc{c}{P} \otimes \proc{d}{Q_i} } \\
  %
  \irb{lolli} \hspace{1em} & : \proc{c}{\trecv{x}{c}{P_x}} \otimes \proc{d}{\tsend{c}{x}{Q_x}{R}} \\
    & \hspace{2em} \lolli \monad{ \exists a. \proc{c}{P_{a}} \otimes \proc{a}{Q_a} \otimes \proc{d}{R} } \\
  %
  \irb{external} \hspace{1em} & : \proc{c}{\tcase{c}{\tbranches P I}} \otimes \proc{d}{\tselect c i Q} \otimes i \in I \\
    & \hspace{2em} \lolli \monad{ \proc{c}{P_i} \otimes \proc{d}{Q} } \\
\end{align*}


\section{Typing of Process Configurations}

A process configuration is a list of processes. We define a new judgment $\provides{\Omega}{\ctx}$ to mean configuration $\Omega$ provides the channels in $\ctx.$ This judgment is inductively defined as follows:

\begin{mathpar}
  \infer{\provides{(\cdot)}{\cdot}}
   {}
  \and \infer{\provides{\parens{\proc{c}{P}, \Omega}}{\ctx, c : A}}
   { \typeS{\ctx'}{P}{c}{A}
   & \provides{\Omega}{\ctx, \ctx'}
   }
\end{mathpar}

It is useful to have the following reordering and inversion lemmas about configuration typings.

\begin{lemma}[Reordering]
  \label{config-reorder}
\end{lemma}

\begin{lemma}[Inversion]
  \label{config-invert}
  If $\provides{\Omega_1, \proc c P, \Omega_2}{\ctx},$ then there exists a type $A,$ contexts $\ctx_1$ and $\ctx_2,$ and a derivation with two ``holes'' $\DD[\cdot, \cdot]$ such that
  \begin{itemize}
    \item $\typeS{\ctx_2}{P}{c}{A},$
    \item $\provides{\Omega_2}{\ctx_1, \ctx_2},$
    \item For all $\Omega_2',$ $P',$ $\ctx_2',$ if $\EE$ is a derivation of $\typeS{\ctx_2'}{P'}{c}{A}$ and $\FF$ is a derivation of $\provides{\Omega_2'}{\ctx_1, \ctx_2'}$ then $\DD[\EE, \FF]$ is a derivation of $\provides{\Omega_1, \proc{c}{P'}, \Omega_2'}{\ctx}.$
  \end{itemize}
\end{lemma}
\begin{proof}
By induction on $\config_1$ (I think).
\end{proof}

\begin{lemma}[Insertion]
  \label{config-insert}
  The following hold:
  \begin{itemize}
    \item If $\provides{\config}{\ctx_1, c : A_1, \ctx_2}$ and $\provides{\config}{\ctx_1, c : A_2, \ctx_2}$ then $\provides{\config}{\ctx_1, c : A_1 \intersect A_2, \ctx_2}.$
    \item If $\provides{\config}{\ctx_1, c : A, \ctx_2}$ then $\provides{\config}{\ctx_1, c : A \union B, \ctx_2}$ and $\provides{\config}{\ctx_1, c : B \union A, \ctx_2}.$
    \item If $\provides{\config}{\ctx_1, c : A, \ctx_2}$ and $A \sub A'$ then $\provides{\config}{\ctx_1, c : A', \ctx_2}.$
  \end{itemize}

\end{lemma}


\section{Progress}

To state the progress theorem, we introduce a new judgment $\poised{\proc c P}.$ Intuitively, a process is poised if it is waiting on its client.

\begin{mathpar}
  \infer{\poised{\proc{c}{\tclose{c}}}}
   {}
  \and \infer{\poised{\proc{c}{\tsend{c}{d}{P_d}{Q}}}}
   {}
  \and \infer{\poised{\proc{c}{\trecv{x}{c}{Q_x}}}}
   {}
  \and \infer{\poised{\proc{c}{\tselect{c}{i}{P}}}}
   {}
  \and \infer{\poised{\proc{c}{\tcase{c}{\tbranches{Q}{I}}}}}
   {}
\end{mathpar}

We say that a process configuration $\config$ is poised if every process in $\config$ is poised.  Now we can state the progress theorem.

\begin{theorem}[Progress]
If $\provides{\config}{\ctx}$ then either
\begin{enumerate}
  \item $\steps{\config}{\config'}$ for some $\config'$, or
  \item $\config$ is poised.
\end{enumerate}
\end{theorem}

\begin{proof}
The proof is by induction on $\provides{\config}{\ctx}.$
\begin{itemize}
  \item Case for $\parens{\cdot}.$ All processes are poised vacuously.
  \item Case for $\parens{\proc{c}{P}, \config}.$ The induction hypothesis applies to $\config.$ If $\config$ can transition, then $\proc{c}{P}, \config$ can transition. Otherwise, all processes in $\config$ are poised.

  Define $\pred{\typeS{\ctx'}{P}{c}{A}} :=$ either $\proc{c}{P}$ is poised or $\proc{c}{P}, \config$ can transition. We induct on the derivation of $\typeS{\ctx'}{P}{c}{A}.$
  \begin{description}
    \item[Case $\id:$] $\proc c P$ forwards and immediately terminates.
    \item[Case $\cut:$] $\proc c P$ spawns a new process.
    \item[Case $\terminate\Right, \tensor\Right, \internal\Right, \lolli\Right, \external\Right :$] $\proc c P$ is poised.
    \item[Case $\terminate\Left, \tensor\Left, \internal\Left, \lolli\Left, \external\Left :$] In each case, we have $\ctx' = \ctx'', d : D.$ By inversion on $\provides{\config}{\ctx, \ctx'', d : A},$%
    \footnote{TODO: Reordering lemma.}
    we get that there exist a process $\proc{d}{Q}$ in $\config$ and $\ctx_Q$ such that $\typeS{\ctx_Q}{Q}{d}{D}.$ Since $\proc{d}{Q}$ is poised by assumption, one of the normal forms lemmas%
    \footnote{TODO: This is the trick part requiring at least an induction per lemma.} gives a matching form $Q.$ $P$ and $Q$ then take a matching step.
    % \item[Case $\terminate L:$] $P = \twait d {P'}.$ By inversion, there is a process $\proc d Q$ in $\config$ that is poised. Inversion on the poised judgement gives $Q = \tclose d.$ Thus, $\irb{one}$ applies.
    \item[Case $\intersect\Right, \union\Left, \irb{Sub}\Right, \irb{Sub}\Left$] Follows immediately by IH. For intersection, either branch works. \todo{2 missing cases!}
  \end{description}
\end{itemize}
\end{proof}


\section{Preservation}
Proving preservation is trickier. Here is the theorem.

\begin{theorem}[Preservation]
If $\provides{\config}{\ctx}$ and $\steps{\config}{\config'}$ then $\provides{\config'}{\ctx}.$
\end{theorem}
\begin{proof}
  The proof proceeds by case analysis on $\steps{\config}{\config'}$ followed by induction on the configuration typing (by the use of Lemma \ref{config-invert}), and induction on the typing derivations of the involved processes. Whenever two processes communicate, we will assume that the provider and the client are next to each other by using Lemma \ref{config-reorder}.
  \begin{description}
    \item[\irb{id}]
    \item[\irb{cut}]
    \item[\irb{one}] $\Omega = \Omega_1, \proc{c}{\twait{d}{P}}, \proc{d}{\tclose d}, \Omega_2.$ By Lemma \ref{config-invert}, we know $\typeS{\ctx_2, d : D}{\twait{d}{P}}{c}{A}$ and $\provides{\proc{d}{\tclose d}, \Omega_2}{\ctx_1, \ctx_2, d : D}$ for some $A,$ $D,$ $\ctx_1,$ and $\ctx_2$; and that it suffices to show $\typeS{\ctx_2}{P}{c}{A}$ and $\provides{\Omega_2}{\ctx_1, \ctx_2}.$ We proceed by induction on $\typeS{\ctx_2, d : D}{\twait{d}{P}}{c}{A}.$ The only applicable cases are $\irb{Sub}\Right,$ $\intersect\Right,$ $\irb{Sub}\Left,$ $\union\Left,$ and $\terminate\Left.$

    \begin{description}
      \item[Case $\irb{Sub}\Right:$] The induction hypothesis gives $\typeS{\ctx_2}{P}{c}{A'}$ and $\provides{\Omega_2}{\ctx_1, \ctx_2}$ where $A' \sub A.$ Then by $\irb{Sub}\Right,$ we get $\typeS{\ctx_2}{P}{c}{A}$ as desired.

      \item[Case $\intersect\Right:$] IH gives $\typeS{\ctx_2}{P}{c}{A_1},$ $\typeS{\ctx_2}{P}{c}{A_2},$ and $\provides{\Omega_2}{\ctx_1, \ctx_2}$ where $A = A_1 \intersect A_2.$ The result follows from $\intersect\Right.$

      \item[Case $\irb{Sub}\Left:$]
      \item[Case $\union\Left:$] If the rule is applied with $d$ then either of the induction hypotheses gives the desired result immediately. Otherwise, we get $\typeS{\ctx_2', e : E_1, \ctx_2''}{P}{c}{A},$ $\provides{\Omega_2}{\ctx_1, \ctx_2', e : E_1, \ctx_2''},$ and $\typeS{\ctx_2', e : E_2, \ctx_2''}{P}{c}{A},$ $\provides{\Omega_2}{\ctx_1, \ctx_2', e : E_2, \ctx_2''}$ where $\ctx_2 = \ctx_2', e : E_1 \union E_2, \ctx_2''.$ We get $\typeS{\ctx_2}{P}{c}{A}$ by $\union\Left$ and $\provides{\Omega_2}{\ctx_1, \ctx_2}$ by Lemma \ref{config-insert}.

      \item[Case $\terminate\Left:$] We know $\typeS{\ctx_2}{P}{c}{A}$ and $D = \terminate.$ By inversion on $\provides{\proc{d}{\tclose d}, \Omega_2}{\ctx_1, \ctx_2, d : D},$ we know $\typeS{\ctx_3}{\tclose{d}}{d}{1}$ and $\provides{\config}{\ctx_1, \ctx_2, \ctx_3}.$
    \end{description}
  \end{description}

  The proof is too complicated and has way too many cases. Here are some (bad) ways to fix it:
  \begin{itemize}
    \item Force an interaction even with property rules like $\irb{Sub}\Right,$ $\irb{Sub}\Left,$ $\intersect\Right,$ and $\union\Left.$ This is very hard to make work and does not make much sense.
    \item At least make sure that when two processes interact, the client uses a left rule only on the physically interacted provider and no one else. This restriction shouldn't make any programs impossible to write since a process has to interact with every process it has (and even if it didn't it's type would not matter.) I remember this coming up in my old  proof but for some reason I thought it was impossible back then.
  \end{itemize}
\end{proof}

% \begin{proof}
% The proof proceeds by case analysis on $\steps{\config}{\config'}$ followed inversion on the configuration typing, and induction on the typing derivations of the involved processes. The cases for \irb{id} and \irb{cut} are simple. All other cases either send or receive a message. We will only show the \irb{sendval} case to keep things simple (all cases are very similar). We will assume that the client and the provider are next to each other (using a lemma similar to the permutation lemma from the paper).

% \begin{description}
%   \item[Case \irb{sendval}:] By inversion, we have
%   \[
%   \infer{\provides{\parens{\proc{c}{\tsendval{d}{M}{P}}, \Omega}}{\ctxChan, c : A}}
%    { \typeS{\emptyCtx}{\ctxChan', d : B}{\proc{c}{\tsendval{d}{M}{P}}}{c}{A}
%    & \provides{\Omega}{\ctxChan, \ctxChan', d : B}
%    }
%   \]
%   Also by inversion, we have $\typeS{\emptyCtx}{\ctxChan''}{\proc{d}{\trecv{x}{d}{Q}}}{d}{B}.$ 
  
%   Define $\pred{\typeS{\emptyCtx}{\ctxChan', d : B}{\proc{c}{\tsendval{d}{M}{P}}}{c}{A}} :=$ there exists $B'$ such that $\typeS{\emptyCtx}{\ctxChan', d : B'}{\proc{c}{P}}{c}{A}$ and $\typeS{\emptyCtx}{\ctxChan''}{\proc{d}{Q_M}}{d}{B'}.$ We need the use induction (on the derivation of the process typing) due to the intersection rules.
%   \begin{itemize} 
%     \item Case for $\intersect R:$ $A = A_1 \intersect A_2.$ By IH$_1$, there is $B_1$ such that $\typeS{\emptyCtx}{\ctxChan', d : B_1}{\proc{c}{P}}{c}{A_1}$ and $\typeS{\emptyCtx}{\ctxChan''}{\proc{d}{Q_M}}{d}{B_1}.$ IH$_2$ gives a similar result for $A_2$ and a $B_2.$ We then have $\typeS{\emptyCtx}{\ctxChan''}{\proc{d}{Q_M}}{d}{B_1 \intersect B_2}$ by $\intersect R.$ Finally, $\intersect R$ followed by $\intersect L_1$ and $\intersect L_2$ for the respective branches gives $\typeS{\emptyCtx}{\ctxChan', d : B_1 \intersect B_2}{\proc{c}{P}}{c}{A}.$
%     \item Case for $\intersect L_1:$ $B = B_1 \intersect B_2.$ The result follows immediately from IH (we essentially ignore the right branch).
%     \item Case for $\intersect L_2$ is similar. 
%     \item Case for $\lolli L $ (i.e. the base case): $B = \tau \lolli B'.$ We have $\typeS{\emptyCtx}{\ctxChan', d : B'}{\proc{c}{P}}{c}{A}$ from the premises. For the second part, we use another induction. There are three applicable rules ($\lolli R$, $\intersect L_1$, $\intersect L_2$). If the last rule was $\lolli R,$ we have $\typeS{\emptyCtx}{\ctxChan''}{\proc{d}{Q_M}}{d}{B'}$ from the premises. Otherwise, IH along with $\intersect L_1$ or $\intersect L_2$ gives the desired result.
%   \end{itemize}
%   The predicate $\mathcal{P}$ needs to be stated slightly differently for other cases (for example, the provider disappears in \irb{one}). But the idea is essentially the same.
% \end{description}
% \end{proof}

\section{Todo}

\begin{enumerate}
  \item Prove progress.
  \item Formalize reordering of process configurations.
  \item Prove normal form lemmas.
  \item Add recursive types.
  \item Distributivity.
  \item Formalize symmetry and transitivity of $\union$ and $\intersect$ so we claim order doesn't matter (formalize what that means too).
  \item Formalize distributivity of $\union$ on $\intersect$ (refer to notebook).
\end{enumerate}

\end{document}
