
\section{Compiling Choice Away}

In the previous section, we saw how we can use intersections and unions to represent $n$-ary choice using only singleton choice. In this section, we will remove choice operators all together to get a simpler type system.

To facilitate the discussion, consider the singleton external choice, and specifically, what it means: a process $P$ that has the type $\externalSing \lab A$ will first receive the label $\lab$, and then act as $A$. We already have a construct in the language that represents receiving, namely $\lolli$. This suggest the definition $\externalSing \lab A \defined (? \lolli A)$, but what do we put for $?$. Ideally, we would have a type $\singleton{\lab}$ which is the singleton type containing
the label $\lab$, however, labels lend themselves as values rather than processes. We could use the value level construct $\recvVal$ from (\todo{add citation}), but introducing a functional level would add extra complexity.

A slick \todo{Find a better word that means small, tricky, elegant.} solution is to encode $\singleton \lab$ as a process that sends out the label $\lab$ and immediately terminates. At this point, the acute reader might notice that we already have a type for processes which behave almost exactly in this way. A process of type $\terminate$ will send out the predetermined label $\irb{end}$ and terminate. So, instead of introducing a new type construct, we
slightly modify the existing $\terminate$ and replace it with the set of type constructors $\setdef{\singleton \lab}{\lab \in \labels}$, so that instead of sending a globally fixed message, a terminating process can send an arbitrary but prefixed message.

We also modify the corresponding process expressions to reflect the change in types. The terminating provider specifies the label to send: $\tcloseLab c \lab$. Perhaps unexpectedly, the client does not wait on a specific label, but instead cases on the received label. This makes sense since we want to be able to handle types such as $\singleton{\lab_1} \union \singleton{\lab_2}$. Thus, the new for is $\twaitLab c {\tbranches P I}$. The new typing rules are provided in \cref{labelled-termination}.

\begin{rules}[labelled-termination]{Typing rules for labelled termination}
  \infer[\terminate\Right]{\typeD{\emptyCtx}{\tcloseLab c \lab}{c}{\singleton \lab}}
    {}
  \and \infer[\terminate\Left]{\typeD { \ctx, c : \singleton {\lab_i} } { \twaitLab{c}{\tbranches P I} } d D }
   { i \in I
   & \typeDJ{P_i}{d}{D}
   }
\end{rules}

\todo{Talk about how the expressions get compiled.}

