
\section{Interpretation of Property Types}

In this section, we will develop a tool for handling intersection and unions in a more semantic way. First, we define a syntactic lattice of propositions, $\propLattice$, in order to mirror intersection and union:
$$
\propLattice = p \in \props
             \mid \propLattice \vee \propLattice
             \mid \propLattice \wedge \propLattice
$$
Here, $\props$ is the set of propositions. There is an obvious map from $\propLattice$ into propositions which interprets $\wedge$ as conjunction and $\vee$ as disjunction. We will not write this conversion explicitly and instead treat the syntactic and semantics forms interchangeably.

We will want to interpret the types, contexts, judgements, and other objects in our system into this lattice. Since we want to interpret many different objects, we will define the interpretation function in an ad hoc polymorphic way given a pair of sets. For a pair of sets $\pair {T_1} {T_2}$, the interpretation (if it exists) is a function with the signature:
$$
  \interpGJ X {\pair f g}  : T_1 \to (T_2 \to \propLattice) \to \propLattice
$$
where $f, g : \propLattice \to \propLattice \to \propLattice$. Note that the definition is parametric on $f,g$. We will assume $f,g \in \set{\vee, \wedge}$, \todo{Can we be more generic?} and define the following shortcuts:
\begin{mathpar}
  \interpJ X = \interpGJ X {\pair \vee \wedge}
  \and \interpCJ X = \interpGJ X {\pair \wedge \vee}
  \\ \interpVeeJ X = \interpGJ X {\pair \vee \vee}
  \and \interpWedgeJ X = \interpGJ X {\pair \wedge \wedge}
\end{mathpar}
\todo{Explain these.} We will drop the $\mathcal P$ when it is the identity function, or when ther is an obvious way to go from $T_2$ to a proposition (for example, if $x \in T_2$ is a judgement, then $\mathcal P {(x)}$ would be $x$ holds).

Most judgements we have defined, such as subtyping and algorithmic typing, have the property that rules concerning property types are invertible and thus can be applied eagerly at the beginning. If we think of applying these rules as generating a decision tree, we have structural rules at the leaves. Most theorems come down to traversing this tree in a boring obvious way and resolving the leaves, which is the hard part. This suggests mapping $\intersect$ to $\wedge$, $\union$ to $\vee$, and structural types to a proposition according to some function $\mathcal P$.

Let $\typesStruct$ be the set of types where the top level construct is structural (i.e.\ not $\intersect$, $\union$, or $\mu$). We can define interpretation for $\pair \types \typesStruct$ as follows:
\begin{mathpar}
  \interpGJ{A_1 \union A_2}{\pair f g} = f\parens*{\interpGJ{A_1}{\pair f g}, \interpGJ{A_2}{\pair f g}}
  \\ \interpGJ{A_1 \intersect A_2}{\pair f g} = g\parens*{\interpGJ{A_1}{\pair f g}, \interpGJ{A_2}{\pair f g}}
  \\ \interpGJ{\recursive t {A_t}}{\pair f g} = \interpGJ{\subst {\recursive t {A_t}} t {A_t}}{\pair f g}
  \\ \interpGJ{A}{\pair f g} = \mathcal{P}\parens*{A} ~~~ \text{ if } A \in \typesStruct
\end{mathpar}
Note that this is defined by induction on $\size A$. Also note that the default interpretation which uses $\vee$ for $f$ and $\wedge$ for $g$ fits the above intuition. Extending this to multisets of types is straightforward:
\begin{mathpar}
  \interpGJ{A_1, \ldots, A_n}{\pair f g}
   = \interpGJ{A_1}{\pair f g} \mathrel{f} \ldots \mathrel{f} \interpGJ{A_n}{\pair f g}
\end{mathpar}
writing $f$ as infix.
%
As for contexts, assume $\mathcal P$ is a proposition over contexts containing only structural types. Then, the interpretation simply chains all channels together:
\begin{mathpar}
  \interpGJ{c_1 : \typeList_1, \ldots, c_n : \typeList_n} M
   = \interpG {\typeList_1} M
      { \lam {A_1} {( \ldots
         \interpG {\typeList_n} M { \lam {A_n} {\mathcal P {\parens{c_1 : A_1, \ldots, c_n : A_n}}} }
        \ldots)}
      }
\end{mathpar}

We can now express subtyping and process typing using these definitions. This allows us to pull top level intersections and unions to the meta level, which means we only need to deal with structural rules.
\begin{mathpar}
  \interpGJ {\typeList \subA \typeListB} {\pair f g}
   = \interpG {\typeList} {\pair g f}
      {\lam {A}
        {\interpG {\typeListB} {\pair f g}
          {\lam {B} {\mathcal P {\parens*{A \subAStruct B}}} }
        }
     }
  \\ \interpGJ {\typeRecAJ P c \typeList} {\pair f g}
   = \interpG {\ctx} {\pair g f}
      {\lam {\ctx'}
        {\interpG {\typeList} {\pair f g}
          {\lam {A} {\mathcal P {\parens*{\typeRecAJRStruct {\ctx'} P c A}}} }
        }
     }
\end{mathpar}
Note how the functions in the interpretation are flipped for types on the left. Also keep in mind that these are defined over the judgements, not their derivations. Subtyping and process typing are related to the definitions above with the following \namecref{algorithmic:interpretation-commutes}:
\begin{theorem}
  \label{algorithmic:interpretation-commutes}
  \todo{Name this theorem.}
  The following hold:
  \begin{itemize}
  \item $\typeList \subA \typeListB \iff \interpP {\typeList \subA \typeListB}$
  \item $\typeRecAJ P c \typeList \iff \interpP {\typeRecAJ P c \typeList}$
  \end{itemize}
\end{theorem}
\begin{proof}
  Follows from \cref{algorithmic:property-invertible} and the distributivity of intersections and unions over each other. The proof crucially depends on distributivity of property types over each other and the fact that there is no distributivity over structural types. That is, at some point we have to commit to one structure. \todo{Do this formally.}
\end{proof}


\subsection{Properties}


\begin{lemma}[Commutativity]
  \label{algorithmic:interpretation-commutes}
  Nested uses of interpretation commute:
  $$\interpG X M {\lam x {\interpG Y N {\lam y {\mathcal P {\parens{x, y}}} } }}
  \iff \interpG Y N {\lam y {\interpG X M {\lam x {\mathcal P {\parens{x, y}}} } }}.
  $$
\end{lemma}
\begin{proof}
  \todo{Check this proof.}
\end{proof}

\begin{lemma}
  \label{algorithmic:interpretation-connectives}
  The following are admissible:
  \begin{itemize}
    \item $\interpG X M {\mathcal P \wedge \mathcal Q} \implies \interpG X M {\mathcal P} \wedge \interpG X M {\mathcal Q}$
    \item $\interpG X M {\mathcal P} \vee \interpG X M {\mathcal Q} \implies \interpG X M {\mathcal P \vee \mathcal Q}$
    \item $\interpG X M {\mathcal P \implies \mathcal Q} \wedge \interpG X M {\mathcal P} \implies \interpG X M {\mathcal Q}$
  \end{itemize}
  where $\wedge$, $\vee$, and $\implies$ over functions is defined pointwise.
\end{lemma}
\begin{proof}
  By induction over the structure of conjunctions and disjunctions in the interpretation of $X$.
\end{proof}


\begin{lemma}
  \label{algorithmic:interpretation-mix}
  The following is admissible:
  $$ \parens*{\interpJ X \wedge \interpCJ Q \wedge
     \interpWedge X {\lam x {\mathcal P {(x)} \wedge \mathcal Q {(x)} \implies R }} }
     \implies R.$$
\end{lemma}
\begin{proof}
  By induction over the structure of conjunctions and disjunctions in the interpretation of $X$.
\end{proof}

