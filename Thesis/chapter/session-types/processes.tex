
\section{Process Expressions}

Below is a summary of the process expressions, with the sending construct
followed by the matching receiving construct.

\begin{center}
\begin{tabular}{l c l l}
  $P, Q, R$ & ::= & $\tspawn{x}{P_x}{Q_x}$     & cut (spawn) \\
            & $|$ & $\tfwd c d$                & id (forward) \\
            & $|$ & $\tclose c \mid \twait c P$  & $\terminate$ \\
            & $|$ & $\tsend{c}{y}{P_y}{Q} \mid \trecv{x}{c}{R_x}$ & $A \tensor B,$ $A \lolli B$ \\
            & $|$ & $\tselect{c}{}{P} \mid \tcase c {\tbranches Q i}$  & $\externals A I,$ $\internals A I$ \\
            & $|$ & $\tsendVal{c}{M}{Q} \mid \trecvVal{n}{c}{R_n}$ & $A \sendVal B,$ $A \recvVal B$
\end{tabular}
\end{center}

Let us consider an example program to get more intuition about the system. We will use process level natural numbers, $\nat$, as a running example. Note that we use concrete syntax to write programs, but the mapping to abstract syntax presented above should be clear. Also, this example (and almost any interesting one) requires recursive types, which are introduced in \cref{base:recursion}.

First, we define the interface:

\begin{lstlisting}[language=krill, style=custom]
  type Nat = +{zero : 1, succ : Nat}
\end{lstlisting}

The interface states that a process level natural number is an internal choice of either zero or a successor of another natural. Next, we define two simple processes that implement the interface:

\begin{minipage}{.48\textwidth}
\begin{lstlisting}[language=krill, style=custom]
  z : Nat
  `c <- z =
    `c.zero;
    close `c
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[language=krill, style=custom]
  s : Nat -o Nat
  `c <- s `d =
    `c.succ;
    `c <- `d
\end{lstlisting}
\end{minipage}

\texttt{z} simply sends the label \texttt{zero} along the channel \texttt{`c} (which it provides) and terminates, whereas \texttt{s} prepends a successor to the number provided along channel \texttt{`d} and then delegates to \texttt{`d}. Here is a slightly more complicated example that uses recursion:

\begin{lstlisting}[language=krill, style=custom]
  double : Nat -o Nat
  `c <- double `d =
    case `d of
      zero -> wait `d; `c.zero; close `c
      succ -> `c.succ; `c.succ; `c <- double `d
\end{lstlisting}


\subsection{Type Assignment for Processes}

The typing rules for other constructs are derived from linear logic by decorating derivations with proof terms. The rules are given in \cref{session-assignment}. Note that we allow unused branches case expressions for $\internal\Left$ and $\external\Right$, which makes width subtyping easier (discussed in \cref{base:subtyping}).

\begin{rules}[session-assignment]{Process assignment}
  % id and cut
  \infer[\id]{ \typeD {c : A} {\tfwd{d}{c}} {d} {A} }
    {}
  \and \infer[\cut]{ \typeD {\ctx, \ctx'} {\tspawn{c}{P_c}{Q_c}} {d} {D} }
    { \typeD {\ctx} {P_c} {c} {A}
    & \typeD {\ctx', c : A} {Q_c} {d} {D}
    }
  % Terminate
  \and \infer[\terminate\Right]{\typeD{\emptyCtx}{\tclose c}{c}{\terminate}}
    {}
  \and \infer[\terminate\Left]{\typeD{\ctx, c : \terminate}{\twait c P}{d}{A}}
    {\typeDJ{P}{d}{A}}
  % Tensor
  \and \infer[\tensor\Right]{\typeD{\ctx, \ctx'}{\tsend{c}{d}{P_d}{Q}}{c}{A \tensor B}}
    { \typeD{\ctx}{P}{d}{A}
    & \typeD{\ctx'}{Q}{c}{B}
    }
  \and \infer[\tensor\Left]{ \typeD{\ctx, c : A \tensor B}{\trecv{d}{c}{P_d}}{e}{E} }
    { \typeD{\ctx, d : A, c : B}{P_d}{e}{E} }
  % Internal choice
  \and \infer[\internal\Right]{\typeDJ { \tselect{c}{i}{P} } {c} {\internals{A}{I}} }
    { i \in I
    & \typeDJ{P}{c}{A_i}
    }
  \and \parens*{\infer[\internal\Right]{\typeDJ { \tselect{c}{}{P} } {c} {\internal \braces{\lab : A}} }
    { \typeDJ{P}{c}{A}
    }
  }
  \and \infer[\internal\Left]{ \typeD { \ctx, c : \internals{A}{I} } { \tcase{c}{\tbranches{P}{J}} } {d} {D} }
   { I \subseteq J
   & \typeD{\ctx, c : A_k}{P_k}{d}{D}~\text{for}~k\in I
   }
  % Implication
  \and \infer[\lolli\Right]{ \typeD{\ctx}{\trecv{d}{c}{P_d}}{c}{A \lolli B} }
    { \typeD{\ctx, d : A}{P_d}{c}{B} }
  \and \infer[\lolli\Left]{\typeD{\ctx, \ctx', c : A \lolli B}{ \tsend{c}{d}{P_d}{Q} } {e}{E}}
    { \typeD{\ctx}{P_d}{d}{A}
    & \typeD{\ctx', c : B}{Q}{e}{E}
    }
  % External choice
  \and \infer[\external\Right]{ \typeDJ { \tcase{c}{\tbranches{P}{I}} } {c} {\externals{A}{J}} }
   { J \subseteq I
   & \typeDJ{P_k}{c}{A_k}~\text{for}~k\in J
   }
  \and \infer[\external\Left]{\typeD{\ctx, c : \externals{A}{I}} { \tselect{c}{i}{P} } {d} {D}}
    { i \in I
    & \typeD{\ctx, c : A_i}{P}{d}{D}
    }
\end{rules}

As usual, we identify bound channels up to alpha conversion. We can change free channel names while preserving typing as formalized below:
\begin{lemma}[Channel Substitution]
  \label{channel-substitution-pre}
  If $\typeDJ P c A$ and $\tvector z \cap \free {\parens P} = \emptyset$ then $\typeD {\subst {\tvector z} {\tvector y} \ctx} {\subst {\tvector z} {\tvector y} P} {\subst {\tvector z} {\tvector y} c} A$.
\end{lemma}

We delay the proof until after we introduce recursive types since the typing-derivation will be changed slightly.


